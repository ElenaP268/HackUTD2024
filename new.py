# -*- coding: utf-8 -*-
"""linear-reg-model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WvQEAmy_Lzs7-7GYZof_I798HHBVEbux
"""

import pandas as pd
import matplotlib.pyplot as plt
import sklearn

df = pd.read_csv('Resolute_728H-10_14-10_21.csv')  # Replace with your actual CSV file path

# Display the first few rows of the data to understand its structure
print(df.head())

# Fill forward missing values in a specific column (e.g., 'column_name')
df['Inj Gas Valve Percent Open'] = df['Inj Gas Valve Percent Open'].fillna(method='ffill')
df['Inj Gas Meter Volume Setpoint'] = df['Inj Gas Meter Volume Setpoint'].fillna(method='ffill')
df['Inj Gas Meter Volume Instantaneous'] = df['Inj Gas Meter Volume Instantaneous'].fillna(method='ffill')


# Optionally, save the updated DataFrame back to a CSV file
df.to_csv('updated_file.csv', index=False)

df.head()

# Count NA values for each column
na_counts_per_column = df.isna().sum()

# Count total NA values in the entire DataFrame
total_na_count = df.isna().sum().sum()

# Print the count of NA values per column
print("NA values per column:")
print(na_counts_per_column)

# Print the total number of NA values in the DataFrame
print(f"\nTotal number of NA values in the DataFrame: {total_na_count}")

df.head()

# excel formulas translated
# Create a new column 'accumulated' starting with the value of 'B2'
df['accumulated_sum'] = df['Inj Gas Meter Volume Instantaneous']  # Start by copying column B to the new column

# Apply the accumulation logic from row 3 onwards (index 1, because pandas is 0-based)
for i in range(1, len(df)):
    df.loc[i, 'accumulated_sum'] = df.loc[i, 'Inj Gas Meter Volume Instantaneous'] + df.loc[i-1, 'accumulated_sum']

# Save the updated DataFrame back to a new CSV file
df.to_csv('updated_file_accumulated.csv', index=False)

print(df.head())

df.head()

# Apply the formula: E3 * (1 - D3/100) for each row
df['total_volume'] = df['accumulated_sum'] * (1 - df['Inj Gas Valve Percent Open'] / 100)

# Optionally, save the updated DataFrame back to a CSV file
df.to_csv('updated_file_total_volume.csv', index=False)

df.head()

# Apply the formula: ABS(C2 - B2) for each row
df['volume_difference'] = abs(df['Inj Gas Meter Volume Setpoint'] - df['Inj Gas Meter Volume Instantaneous'])

# Optionally, save the updated DataFrame back to a CSV file
df.to_csv('updated_file_volume_diff.csv', index=False)

df.head()

# Ensure that the values in column 'A' are in datetime format
# If they are not in datetime format, you'll need to convert them
df['Time'] = pd.to_datetime(df['Time'])

# Calculate the time difference in seconds between each row and the first row
df['numeric_time'] = (df['Time'] - df['Time'].iloc[0]).dt.total_seconds()

# Optionally, save the updated DataFrame back to a new CSV file
df.to_csv('updated_file_numeric_time.csv', index=False)

df.head()

df = pd.read_csv('updated_file_numeric_time.csv')  # Replace with your actual CSV file path

# Create a scatter plot between 'time' and another variable, e.g., 'B'
plt.figure(figsize=(8, 6))  # Optional: Set the size of the plot
plt.scatter(df['numeric_time'], df['total_volume'], color='blue', label='B vs Time')

# Add labels and title
plt.xlabel('Time (seconds)')
plt.ylabel('B')
plt.title('Scatter plot of Time vs B')

# Optionally, add a grid and legend
plt.grid(True)
plt.legend()

# Show the plot
plt.show()

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

df = pd.read_csv('updated_file_numeric_time.csv')  # Replace with your actual CSV file path

# Prepare the data
X = df[['numeric_time']]  # Independent variable (must be in 2D array)
y = df['total_volume']    # Dependent variable

# Split the data into training and testing sets (80% training, 20% testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create the linear regression model
model = LinearRegression()

# Train the model
model.fit(X_train, y_train)

# Print the coefficients
print(f"Intercept: {model.intercept_}")
print(f"Coefficient: {model.coef_}")

# Predict values for the test set
y_pred = model.predict(X_test)

'''# Visualize the linear regression line on the scatter plot
plt.scatter(df['numeric_time'], df['total_volume'], color='blue', label='Data')
plt.plot(df['numeric_time'], model.predict(df[['total_volume']]), color='red', label='Regression Line')
plt.title('Linear Regression: numeric_time vs total_volume')
plt.xlabel('x_column')
plt.ylabel('y_column')
plt.legend()
plt.show()'''

# Optionally, you can print the model's performance metrics, like R-squared
from sklearn.metrics import mean_squared_error, r2_score

print(f"Mean Squared Error: {mean_squared_error(y_test, y_pred)}")
print(f"R-squared: {r2_score(y_test, y_pred)}")

# Count NA values for each column
na_counts_per_column = df.isna().sum()

# Count total NA values in the entire DataFrame
total_na_count = df.isna().sum().sum()

# Print the count of NA values per column
print("NA values per column:")
print(na_counts_per_column)

# Print the total number of NA values in the DataFrame
print(f"\nTotal number of NA values in the DataFrame: {total_na_count}")

import numpy as np
# Calculate residuals (actual - predicted)
residuals = y_test - y_pred

# Calculate the standard deviation of residuals
std_residuals = np.std(residuals)

# Define outliers as points where residuals are greater than 2 or 3 standard deviations
outliers = np.abs(residuals) > 2 * std_residuals  # You can change the threshold to 3 if needed

# Get outlier data points
outlier_X = X_test[outliers]
outlier_y_actual = y_test[outliers]
outlier_y_predicted = y_pred[outliers]

# Visualize the linear regression line on the scatter plot
plt.scatter(df['numeric_time'], df['total_volume'], color='blue', label='Data')
plt.plot(df['numeric_time'], model.predict(df[['numeric_time']]), color='red', label='Regression Line')
plt.title('Linear Regression: x_column vs y_column')
plt.xlabel('x_column')
plt.ylabel('y_column')
plt.legend()
plt.show()

# Plot outliers in a different color (red)
plt.scatter(outlier_X, outlier_y_actual, color='red', label='Outliers')
plt.title('Linear Regression with Outliers Highlighted')
plt.xlabel('x_column')
plt.ylabel('y_column')
plt.legend()
plt.show()

# Print outlier details: X values (independent), Actual Y values, and Predicted Y values
print("Outlier X values (Independent variable):")
print(outlier_X)
print("Outlier Actual Y values (Dependent variable):")
print(outlier_y_actual)
print("Outlier Predicted Y values (Predictions):")
print(outlier_y_predicted)

# Optionally, print performance metrics
print(f"Mean Squared Error: {mean_squared_error(y_test, y_pred)}")
print(f"R-squared: {r2_score(y_test, y_pred)}")